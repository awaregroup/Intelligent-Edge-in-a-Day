/*******************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.8.
 *
 * You need to add your implementation here to:
 *    - get telemetry data from device/sensor
 *    - set read-only property data
 *    - handle read-write property callback
 *    - process device command
 *
 * Generated Date: 2/24/2020
 * Modified by Daisuke Nakahara
 *    - add ST SensorTile.Box support
 *    - add Windows and Linux support
 *******************************************************************************************/
#include "azure1_impl.h"
#include "utilities/digitaltwin_serializer.h"
#include "utilities/deviceinfo_interface.h"
#include "utilities/firmware_interface.h"
#include "utilities/acc_interface.h"
#include "utilities/mag_interface.h"
#include "utilities/gyro_interface.h"
#include "utilities/temp_interface.h"
#include "utilities/press_interface.h"
#include "utilities/hum_interface.h"
#include "utilities/mic_interface.h"

#define Payload_Buffer_Size 256

static char osName[Payload_Buffer_Size] = "Unknown";
static char osVer[Payload_Buffer_Size] = "Unknown";
static char procArch[Payload_Buffer_Size] = "Unknown";
static char procModel[Payload_Buffer_Size] = "Unknown";
static char procManufacture[Payload_Buffer_Size] = "Unknown";
static long memTotal = 0;

static unsigned char PresString[45] = "Unknown";

unsigned char FEndOfFrame = TMsg_EOF;
unsigned char FBuffer[FBufferMaxLen];
int FBufferLen;
int SensorWaitTime = 100;
int hComm;

int32_t SendCmd(int serialPort, uint8_t Addr, uint8_t Cmd, uint32_t DataLen, uint8_t* Data);
int32_t ReadCmdResponse(int serialPort, uint8_t Addr, uint8_t Cmd, uint32_t MaxLen, uint8_t* Data);
int ReadDataStreaming(int hComm, SENSOR_DATA* sensorData);
int Send_StopDataStreaming(int hComm);
int Send_StartDataStreaming(int hComm, uint8_t* startingInfo);
void* SensorReadThread(void *arg);

void SendTelemetry_Succeeded_Callback(const char* interfaceName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on success.

    //LogInfo("DigitalTwin successfully delivered telemetry message for component %s", interfaceName);
}

void SendTelemetry_Error_Callback(const char* interfaceName)
{
    // If needed, put your business logic here to handle the confirmation of the delivery for device telemetry on failure.

    LogInfo("DigitalTwin failed to deliver telemetry message for %s", interfaceName);
}

void ReportProperty_Succeeded_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback reporting property on success.

    LogInfo("DigitalTwin successfully report writable property for %s::%s", interfaceName, propertyName);
}

void ReportProperty_Error_Callback(const char* interfaceName, const char* propertyName)
{
    // If needed, put your business logic here to handle the result callback of reporting property on failure.

    LogInfo("DigitalTwin failed to report writable property for %s::%s", interfaceName, propertyName);
}

char* DeviceInfo_Property_GetManufacturer()
{
    FILE *cpuinfo = fopen("/proc/cpuinfo", "r");
    char line[256];
    char tmp1[256];
    char tmp2[256];

    if ((cpuinfo = fopen("/proc/cpuinfo", "r")) != NULL)
    {
        while(fgets(line, 256, cpuinfo))
        {
            sscanf(line, "%s : %[^\n]", tmp1, tmp2);
            if((strcmp(tmp1,"Hardware") == 0))
            {
                snprintf(procManufacture, Payload_Buffer_Size, "%s", tmp2);
                //printf("Manufacturer %s\r\n", tmp2);
                break;
            }
        }
        fclose(cpuinfo);
    }
    return procManufacture;
}

char* DeviceInfo_Property_GetModel()
{
    FILE *cpuinfo;
    char line[256];
    char tmp1[256];
    char tmp2[256];

    if ((cpuinfo = fopen("/proc/cpuinfo", "r")) != NULL)
    {
        while(fgets(line, 256, cpuinfo))
        {
            sscanf(line, "%s : %[^\n]", tmp1, tmp2);
            if (strcmp(tmp1,"Model") == 0)
            {
                snprintf(procModel, Payload_Buffer_Size, "%s", tmp2);
                //printf("Model %s\r\n", tmp2);
                break;
            }
        }
        fclose(cpuinfo);
    }
    return procModel;
}

char* DeviceInfo_Property_GetSwVersion()
{
    struct utsname* buffer;

    buffer = (struct utsname*) malloc(sizeof(struct utsname));
    if (uname(buffer) == 0) {

        snprintf(osVer, Payload_Buffer_Size, "Release %s Version %s", buffer->release, buffer->version);
    }

    return osVer;
}

char* DeviceInfo_Property_GetOsName()
{
    struct utsname* buffer;

    buffer = (struct utsname*) malloc(sizeof(struct utsname));
    if (uname(buffer) == 0) {
        strcpy(osName, buffer->sysname);
    }

    return osName;
}

char* DeviceInfo_Property_GetProcessorArchitecture()
{
    struct utsname* buffer;

    buffer = (struct utsname*) malloc(sizeof(struct utsname));
    if (uname(buffer) == 0) {
        strcpy(procArch, buffer->machine);
    }

    return procArch;
}

char* DeviceInfo_Property_GetProcessorManufacturer()
{
    FILE *cpuinfo;
    char line[256];
    char tmp1[256];
    char tmp2[256];

    if ((cpuinfo = fopen("/proc/cpuinfo", "r")) != NULL)
    {
        while(fgets(line, 256, cpuinfo))
        {
            sscanf(line, "%s : %[^\n]", tmp1, tmp2);
            if((strcmp(tmp1,"Hardware") == 0))
            {
                snprintf(procManufacture, Payload_Buffer_Size, "%s", tmp2);
                //printf("Manufacturer %s\r\n", tmp2);
                break;
            }
        }
        fclose(cpuinfo);
    }

    return procManufacture;
}

long DeviceInfo_Property_GetTotalStorage()
{
    FILE *disksize;
    long size = 0;
    char line[256];
    char tmp1[256];
    
    if ((disksize = fopen("/sys/class/block/mmcblk0/size", "r")) != NULL)
    {
        while(fgets(line, 256, disksize))
        {
            sscanf(line, "%s", tmp1);
            if (strlen(tmp1) > 0)
            {
                size = strtod(tmp1, NULL);
            }
        }
        fclose(disksize);
    }

    return size;
}

long DeviceInfo_Property_GetTotalMemory()
{
    FILE *meminfo;
    char line[256];
    char tmp1[256];
    char tmp2[256];
    char tmp3[12];

    if ((meminfo = fopen("/proc/meminfo", "r")) != NULL)
    {
        while(fgets(line, 256, meminfo))
        {
            sscanf(line, "%s %s %s", tmp1, tmp2, tmp3);
            if((strcmp(tmp1,"MemTotal:") == 0))
            {
                memTotal = strtod(tmp2, NULL);
                //printf("Total Memory %s\r\n", tmp2);
                break;
            }
        }
        fclose(meminfo);
    }

    return memTotal;
}

char* Firmware_Property_GetFirmware_status()
{
	Get_PresentationString(hComm, 43, PresString);
	printf("==================== %s\r\n", PresString);
    return PresString;
}

DIGITALTWIN_COMMAND_RESULT Firmware_Command_FOTA(char* URI_Fota, FIRMWARE_FOTA_FotaResponse* response, unsigned int* statusCode)
{
    // TODO: provide implementation here
    // You need to process the device command, and set the command response and statusCode correspondingly.
    // Finally, return DIGITALTWIN_COMMAND_OK if the command execution succeeded, or 'DIGITALTWIN_COMMAND_ERROR' on failure.

    LogInfo("Parameter: URI_Fota = %s", URI_Fota);

    // Set command response and status code

    response->firmware_result = "abc";

    *statusCode = 200;
    LogInfo("Device executed 'FOTA' command successfully");
    return DIGITALTWIN_COMMAND_OK;
}

void Acc_Telemetry_ReadAcc_value(ACC_ACC_VALUE * acc_value)
{
    acc_value->acc_x = (double)SensorDataCache.accx;
    acc_value->acc_y = (double)SensorDataCache.accy;
    acc_value->acc_z = (double)SensorDataCache.accz;
#ifdef DEBUG
    printf("Acc x %f y %f z %f\r\n", acc_value->acc_x, acc_value->acc_y, acc_value->acc_z);
#endif
}

void Mag_Telemetry_ReadMag_value(MAG_MAG_VALUE * mag_value)
{
    mag_value->mag_x = (double)SensorDataCache.magx;
    mag_value->mag_y = (double)SensorDataCache.magy;
    mag_value->mag_z = (double)SensorDataCache.magz;
#ifdef DEBUG
    printf("Mag x %f y %f z %f\r\n", mag_value->mag_x, mag_value->mag_y, mag_value->mag_z);
#endif
}

void Gyro_Telemetry_ReadGyro_value(GYRO_GYRO_VALUE * gyro_value)
{
    gyro_value->gryo_x = (double)SensorDataCache.gyrox;
    gyro_value->gryo_y = (double)SensorDataCache.gyroy;
    gyro_value->gryo_z = (double)SensorDataCache.gyroz;
#ifdef DEBUG
    printf("Gyro x %f y %f z %f\r\n", gyro_value->gryo_x, gyro_value->gryo_y, gyro_value->gryo_z);
#endif
}

double Temp_Telemetry_ReadTemp_value()
{
#ifdef DEBUG
    printf("temperature %f\r\n", SensorDataCache.temperature);
#endif
    return SensorDataCache.temperature;
}

double Press_Telemetry_ReadPress_value()
{
#ifdef DEBUG
    printf("Pressure %f\r\n", SensorDataCache.pressure);
#endif
    return SensorDataCache.pressure;
}

double Hum_Telemetry_ReadHum_value()
{
#ifdef DEBUG
    printf("humidity %f\r\n", SensorDataCache.humidity);
#endif
    return SensorDataCache.humidity;
}

double Mic_Telemetry_ReadMic_level_value()
{
    return 0.0;
}

int Send_Ping(int hComm)
{
	if (SendCmd(hComm, STEVAL_IDI001V1_ADDR, CMD_Ping, 0, NULL) == -1)
		return -1;
	return ReadCmdResponse(hComm, STEVAL_IDI001V1_ADDR, CMD_Ping, sizeof(TMsg), NULL);
}

int Get_PresentationString(int hComm, int MaxLen, unsigned char* Buffer)
{
	if (SendCmd(hComm, STEVAL_IDI001V1_ADDR, CMD_Read_PresString, 0, NULL) == -1)
		return -1;
	return ReadCmdResponse(hComm, STEVAL_IDI001V1_ADDR, CMD_Read_PresString, MaxLen, Buffer);
}

int Send_StopDataStreaming(int hComm)
{
	if (SendCmd(hComm, STEVAL_IDI001V1_ADDR, CMD_Stop_Data_Streaming, 0, NULL) == -1)
		return -1;
	return ReadCmdResponse(hComm, STEVAL_IDI001V1_ADDR, CMD_Stop_Data_Streaming, sizeof(TMsg), NULL);
}

int Send_StartDataStreaming(int hComm, uint8_t* startingInfo)
{
	if (SendCmd(hComm, STEVAL_IDI001V1_ADDR, CMD_Start_Data_Streaming, 4, startingInfo) == -1)
		return -1;
	return ReadCmdResponse(hComm, STEVAL_IDI001V1_ADDR, CMD_Start_Data_Streaming, sizeof(TMsg), NULL);
}

int InitializeSensorTile(const char* comPort)
{
    struct termios tty;
    int err;
    pthread_t tid;

    hComm = open(comPort, O_RDWR);
    if (hComm < 0) {
        printf("Error %i from open: %s\n", errno, strerror(errno));
    }

    memset(&tty, 0, sizeof tty);

    // Read in existing settings, and handle any error
    if(tcgetattr(hComm, &tty) != 0) {
        printf("Error %i from tcgetattr: %s\n", errno, strerror(errno));
    }

    tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;
    tty.c_iflag &= ~IGNBRK;
    tty.c_lflag = 0;
    tty.c_oflag = 0;                // no remapping, no delays
    tty.c_cc[VMIN]  = 0;            // read doesn't block
    tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout
    tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl

    tty.c_cflag |= (CLOCAL | CREAD);// ignore modem controls,
                                    // enable reading
    tty.c_cflag &= ~(PARENB | PARODD);      // shut off parity
    tty.c_cflag |= 0;
    tty.c_cflag &= ~CSTOPB;
    tty.c_cflag &= ~CRTSCTS;
    tty.c_cc[VMIN]  = 0;
    tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout

    cfsetispeed(&tty, B115200);
    cfsetospeed(&tty, B115200);

    if (tcsetattr(hComm, TCSANOW, &tty) != 0) {
        printf("Error %i from tcsetattr: %s\n", errno, strerror(errno));
    }

    Send_StopDataStreaming(hComm);

	Get_PresentationString(hComm, 43, PresString);

    err = pthread_create(&tid, NULL, &SensorReadThread, NULL);
    if (err != 0)
        printf("\ncan't create thread :[%s]", strerror(err));
    else
        printf("\n Thread created successfully\n");

    return hComm;
}

int ReadDataStreaming(int hComm, SENSOR_DATA* sensorData)
{
	return ReadCmdResponse(hComm, STEVAL_IDI001V1_ADDR, CMD_Start_Data_Streaming, sizeof(SENSOR_DATA), (uint8_t *) sensorData);
}

void CHK_ComputeAndAdd(TMsg* Msg)
{
	unsigned char CHK = 0;
	unsigned int i;

	for (i = 0; i < Msg->Len; i++) {
		CHK -= Msg->Data[i];
	}
	Msg->Data[i] = CHK;
	Msg->Len++;
}

int ByteStuffCopy(unsigned char* Dest, TMsg* Source)
{
	unsigned int i, Count;

	Count = 0;
	for (i = 0; i < Source->Len; i++) {
		switch (Source->Data[i]) {
		case TMsg_EOF:
			Dest[Count] = TMsg_BS;
			Count++;
			Dest[Count] = TMsg_BS_EOF;
			Count++;
			break;
		case TMsg_BS:
			Dest[Count] = TMsg_BS;
			Count++;
			Dest[Count] = TMsg_BS;
			Count++;
			break;
		default:
			Dest[Count] = Source->Data[i];
			Count++;
		}
	}
	Dest[Count] = TMsg_EOF;
	Count++;
	return Count;
}

int32_t SendMsg(int serialPort, TMsg* Msg)
{
	int32_t Count;
	uint8_t My_Buffer[2 * TMsg_MaxLen];

	CHK_ComputeAndAdd(Msg);
	Count = ByteStuffCopy(My_Buffer, Msg);
	if (!write(serialPort, &My_Buffer, Count))
	{
		return 0;
	}

	return 1;
}

int Read(int hComm, unsigned char* Buffer, int NumToRead, int* NumReceived)
{

    //printf("read >>\r\n");
    int l = read(hComm, Buffer, NumToRead);
    //printf("read <<\r\n");
	if (l == 0) return 0;
	*NumReceived = l;
	return 1;
}

int ReverseByteStuffCopy(TMsg* Dest, unsigned char* Source)
{
	int Count = 0, State = 0;

	while ((*Source) != TMsg_EOF) {
		if (State == 0) {
			if ((*Source) == TMsg_BS) {
				State = 1;
			}
			else {
				Dest->Data[Count] = *Source;
				Count++;
			}
		}
		else {
			if ((*Source) == TMsg_BS) {
				Dest->Data[Count] = TMsg_BS;
				Count++;
			}
			else {
				if ((*Source) == TMsg_BS_EOF) {
					Dest->Data[Count] = TMsg_EOF;
					Count++;
				}
				else {
					return 0; // invalid sequence
				}
			}
			State = 0;
		}
		Source++;
	}
	if (State != 0)
		return 0;
	Dest->Len = Count;
	return 1;
}

int CHK_CheckAndRemove(TMsg* Msg)
{
	unsigned char CHK = 0;
	unsigned int i;

	for (i = 0; i < Msg->Len; i++) {
		CHK += Msg->Data[i];
	}
	Msg->Len--;
	return (CHK == 0);
}

int ReadFrame(int hComm, unsigned char* Buffer, int MaxDim, int* FrameAvailable)
{
	int i, k, stopCounter;
	int64_t  tickStart, tickNow;
	if (MaxDim > FBufferMaxLen) return 0;
	*FrameAvailable = 0;
	i = 0;
	stopCounter = 0;

    //get the current number of microseconds since january 1st 1970
    struct timeval ts;
    gettimeofday(&ts,0);
    tickStart = (int64_t)(ts.tv_sec * 1000 + (ts.tv_usec / 1000));

	while (1) {
		if (!Read(hComm, &FBuffer[FBufferLen], FBufferMaxLen - FBufferLen, &k)) return 0;
		FBufferLen += k;
		while (i < FBufferLen) {
			if ((FBuffer[i] == FEndOfFrame) || (i >= (MaxDim - 1))) {
				if (i == 0) {
					FBufferLen--;
					memcpy((char*)FBuffer, (char*)&FBuffer[1], FBufferLen);
				}
				else {
					i++;
					memcpy((char*)Buffer, (char*)FBuffer, i);
					Buffer[i + 1] = FEndOfFrame; // add another EOF after last char
					*FrameAvailable = 1;
					memcpy((char*)FBuffer, (char*)&FBuffer[i], FBufferLen - i);
					FBufferLen -= i;
					return 1;
				}
			}
			else {
				i++;
			}
		}

		//get the current number of microseconds since january 1st 1970
		struct timeval ts;
		gettimeofday(&ts,0);
		tickNow = (int64_t)(ts.tv_sec * 1000 + (ts.tv_usec / 1000));

		if ((tickNow - tickStart) > 3000)
		{
			return 1;
		}
	}
	return 1;
}

int32_t ReceivedMSG(int serialPort, TMsg* Msg)
{
	uint8_t My_Buffer[2 * TMsg_MaxLen];
	int32_t Available;

    // printf(">>ReceivedMSG\r\n");
	if (!ReadFrame(serialPort, My_Buffer, 2 * TMsg_MaxLen, &Available))
		return 0;

	if (!Available)
		return 0;

	if (!ReverseByteStuffCopy(Msg, My_Buffer))
		return 0;

	if (!CHK_CheckAndRemove(Msg))
		return 0;

	return 1;
}

int32_t SendCmd(int serialPort, uint8_t Addr, uint8_t Cmd, uint32_t DataLen, uint8_t* Data)
{
	TMsg Msg;
	uint32_t i;

	Msg.Len = 3 + DataLen;
	Msg.Data[0] = Addr;
	Msg.Data[1] = FDevAddr;
	Msg.Data[2] = Cmd;
	for (i = 0; i < DataLen; i++) {
		Msg.Data[3 + i] = Data[i];
	}
	if (!SendMsg(serialPort, &Msg)) return -1;
	return 1;
}

int32_t ReadCmdResponse(int serialPort, uint8_t Addr, uint8_t Cmd, uint32_t MaxLen, uint8_t* Data)
{
	TMsg Msg;
	uint32_t i;
	uint32_t offset = 3;

    // printf(">> ReadCmdResponse\r\n");
	do {
		if (!ReceivedMSG(serialPort, &Msg))
		{
			return -1;
		}

		if (((int32_t)Msg.Len) < 3)
		{
			return -1;
		}

		if (Msg.Data[0] != FDevAddr)
		{
			return -1;
		}

		if (Msg.Data[1] != Addr)
		{
			return -1;
		}
        // printf("Msg.Data[2] %x\r\n", Msg.Data[2]);
	} while (Msg.Data[2] != (Cmd + CMD_Reply_Add)
		&& Msg.Data[2] != (Cmd));

	if (Data == 0 && Msg.Len != 3)
		return -1;

	if (Cmd == CMD_Sensor)
	{
		offset = 5;
	}

	if (Data)
	{
		for (i = 0; i < (Msg.Len - offset); i++) {
			if (i >= (uint32_t)MaxLen)
				return -1;
			Data[i] = Msg.Data[offset + i];
		}
	}

    //printf("<< ReadCmdResponse\r\n");

	return Msg.Len - 3;
}

void Serialize(unsigned char* Dest, long Source, unsigned int Len)
{
	unsigned int i;
	for (i = 0; i < Len; i++) {
		Dest[i] = Source & 0xFF;
		Source >>= 8;
	}
}

void* SensorReadThread(void *arg)
{
    uint32_t sensors = 0xff;
	SENSOR_DATA sensorData = { 0 };
    unsigned char flag = 0;

	unsigned int accx = 0;
	unsigned int accy = 0;
	unsigned int accz = 0;
	unsigned int gyrox = 0;
	unsigned int gyroy = 0;
	unsigned int gyroz = 0;
	unsigned int magx = 0;
	unsigned int magy = 0;
	unsigned int magz = 0;

    Send_StartDataStreaming(hComm, (uint8_t*)&sensors);

	while (1)
	{
		if (ReadDataStreaming(hComm, &sensorData) > 0)
		{
			flag = sensorData.flag;

			if ((flag & 1U) == 1U)
			{
				(void)memcpy((void*)&accx, &sensorData.accx, sizeof(unsigned int));
				(void)memcpy((void*)&accy, &sensorData.accy, sizeof(unsigned int));
				(void)memcpy((void*)&accz, &sensorData.accz, sizeof(unsigned int));
				Serialize((unsigned char*)&SensorDataCache.accx, accx, 4);
				Serialize((unsigned char*)&SensorDataCache.accy, accy, 4);
				Serialize((unsigned char*)&SensorDataCache.accz, accz, 4);
			}

			if ((flag & 2U) == 2U)
			{
				(void)memcpy((void*)&gyrox, &sensorData.gyrox, sizeof(unsigned int));
				(void)memcpy((void*)&gyroy, &sensorData.gyroy, sizeof(unsigned int));
				(void)memcpy((void*)&gyroz, &sensorData.gyroz, sizeof(unsigned int));
				Serialize((unsigned char*)&SensorDataCache.gyrox, gyrox, 4);
				Serialize((unsigned char*)&SensorDataCache.gyroy, gyroy, 4);
				Serialize((unsigned char*)&SensorDataCache.gyroz, gyroz, 4);
			}

			if ((flag & 4U) == 4U)
			{
				(void)memcpy((void*)&magx, &sensorData.magx, sizeof(unsigned int));
				(void)memcpy((void*)&magy, &sensorData.magy, sizeof(unsigned int));
				(void)memcpy((void*)&magz, &sensorData.magz, sizeof(unsigned int));
				Serialize((unsigned char*)&SensorDataCache.magx, magx, 4);
				Serialize((unsigned char*)&SensorDataCache.magy, magy, 4);
				Serialize((unsigned char*)&SensorDataCache.magz, magz, 4);
			}

			if ((flag & 8U) == 8U)
			{
				(void)memcpy((void*)&SensorDataCache.pressure, &sensorData.pressure, sizeof(float));
			}

			if ((flag & 16U) == 16U)
			{
				(void)memcpy((void*)&SensorDataCache.humidity, &sensorData.humidity, sizeof(float));
			}

			if ((flag & 32U) == 32U)
			{
				(void)memcpy((void*)&SensorDataCache.temperature, &sensorData.temperature, sizeof(float));
			}

			// printf("Flag %02x Time %02d:%02d:%02d.%02d Temp %.2f Hum %.2f Pres %.2f Gyro %d %d %d Mag %d %d %d Acc %d %d %d\r\n", sensorData.flag,
			// 	sensorData.hours,
			// 	sensorData.minutes,
			// 	sensorData.seconds,
			// 	sensorData.sub_seconds,
			// 	SensorDataCache.temperature,
			// 	SensorDataCache.humidity,
			// 	SensorDataCache.pressure,
			// 	(int)SensorDataCache.gyrox,
			// 	(int)SensorDataCache.gyroy,
			// 	(int)SensorDataCache.gyroz,
			// 	(int)SensorDataCache.magx,
			// 	(int)SensorDataCache.magy,
			// 	(int)SensorDataCache.magz,
			// 	(int)SensorDataCache.accx,
			// 	(int)SensorDataCache.accy,
			// 	(int)SensorDataCache.accz);
		}
		ThreadAPI_Sleep(50);
	}

    Send_StopDataStreaming(hComm);
}

